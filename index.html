<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gemeinden ‚Äì Erstmalige Erw√§hnung</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      color-scheme: dark;
      --surface: rgba(15, 23, 42, 0.78);
      --border: rgba(148, 163, 184, 0.35);
      --accent: #38bdf8;
      --accent-muted: rgba(56, 189, 248, 0.35);
      --accent-strong: rgba(248, 113, 113, 0.7);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5f5;
      --bg: radial-gradient(circle at 25% 20%, #0f172a, #020617 65%);
    }

    * {
      box-sizing: border-box;
      -webkit-font-smoothing: antialiased;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text-primary);
    }

    #app {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #map {
      position: absolute;
      inset: 0;
      z-index: 0;
    }

    #overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 400;
    }

    svg.overlay {
      position: absolute;
      overflow: visible;
      pointer-events: none;
    }

    svg.overlay .feature {
      cursor: pointer;
      pointer-events: auto;
      transition: fill 0.2s ease, stroke 0.2s ease;
    }

    svg.overlay .feature:hover,
    svg.overlay .feature.selected {
      filter: brightness(1.05);
    }

    svg.overlay .feature.selected.municipality-level {
      filter: brightness(1.15);
    }

    svg.overlay .germany-mask {
      fill: rgba(15, 23, 42, 0.55);
      pointer-events: none;
    }

    .leaflet-bar a.palette-button span {
      display: inline-block;
      transition: opacity 0.2s ease, filter 0.2s ease;
    }

    .leaflet-bar a.palette-button.palette-off span {
      opacity: 0.35;
      filter: grayscale(0.95);
    }

    .horizontal-slider {
      position: absolute;
      bottom: 1.5rem;
      left: 50%;
      transform: translateX(-50%);
      width: min(520px, calc(100vw - 12rem));
      min-width: 260px;
      z-index: 450;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 0.85rem 1.25rem 1rem;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      gap: 0.6rem;
      box-shadow:
        0 15px 35px rgba(2, 6, 23, 0.4),
        inset 0 0 0 1px rgba(248, 250, 252, 0.04);
      pointer-events: auto;
      backdrop-filter: blur(10px);
    }

    .horizontal-slider.slider-hidden {
      display: none;
    }

    .horizontal-slider .slider-label {
      display: flex;
      align-items: baseline;
      justify-content: center;
      gap: 0.35rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .horizontal-slider .slider-label span {
      font-size: 1.35rem;
      color: var(--text-primary);
      font-weight: 600;
      letter-spacing: 0.01em;
      text-transform: none;
    }

    #year-slider {
      width: 100%;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      cursor: pointer;
    }

    #year-slider:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 4px;
    }

    #year-slider::-webkit-slider-runnable-track {
      height: 10px;
      background: var(--accent-muted);
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.08);
    }

    #year-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid rgba(15, 23, 42, 0.6);
      box-shadow: 0 6px 12px rgba(2, 6, 23, 0.45);
      margin-top: -7px;
    }

    #year-slider::-moz-range-track {
      height: 10px;
      background: var(--accent-muted);
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.08);
    }

    #year-slider::-moz-range-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid rgba(15, 23, 42, 0.6);
      box-shadow: 0 6px 12px rgba(2, 6, 23, 0.45);
    }

    #year-slider::-ms-track {
      height: 10px;
      background: transparent;
      border-color: transparent;
      color: transparent;
    }

    #year-slider::-ms-fill-lower,
    #year-slider::-ms-fill-upper {
      background: var(--accent-muted);
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.08);
    }

    #year-slider::-ms-thumb {
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid rgba(15, 23, 42, 0.6);
      box-shadow: 0 6px 12px rgba(2, 6, 23, 0.45);
    }

    .info-panel {
      position: absolute;
      bottom: 1.5rem;
      left: 1.5rem;
      z-index: 500;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      min-width: 240px;
      max-width: min(360px, calc(100vw - 3rem));
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1rem 1.25rem;
      backdrop-filter: blur(18px);
      box-shadow:
        0 20px 45px rgba(2, 6, 23, 0.45),
        inset 0 0 0 1px rgba(248, 250, 252, 0.04);
      transition: opacity 0.2s ease;
    }

    .info-panel strong {
      font-size: 1.1rem;
      letter-spacing: 0.01em;
    }

    .info-panel.hidden-panel {
      opacity: 0;
      pointer-events: none;
    }

    .info-panel .info-close {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: rgba(15, 23, 42, 0.65);
      color: var(--text-secondary);
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: color 0.2s ease, background 0.2s ease;
    }

    .info-panel .info-close:hover,
    .info-panel .info-close:focus-visible {
      background: rgba(56, 189, 248, 0.2);
      color: var(--text-primary);
      outline: none;
    }

    .loading {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 23, 0.45);
      z-index: 600;
    }

    .loading.hidden {
      display: none;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 3px solid rgba(248, 250, 252, 0.15);
      border-top-color: var(--accent);
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    @media (max-width: 640px) {
      .horizontal-slider {
        width: calc(100vw - 2.5rem);
        left: 50%;
        transform: translateX(-50%);
      }

      .info-panel {
        display: none;
      }

      .info-panel.show-on-mobile {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <div id="map" role="application" aria-label="Gemeindekarte Deutschlands"></div>
    <div id="overlay"></div>
    <div class="horizontal-slider" id="slider-shell" aria-hidden="false">
      <div class="slider-label"><span>Jahr</span><span id="year-slider-value">1850</span></div>
      <input
        type="range"
        id="year-slider"
        min="600"
        max="1850"
        step="1"
        value="1850"
        aria-label="Filter nach erstmaliger Erw√§hnung"
      />
    </div>

    <div class="info-panel" id="info-panel">
      <button class="info-close" id="info-close" aria-label="Info-Panel schlie√üen" type="button">√ó</button>
      <strong id="info-title"></strong>
      <span id="info-detail">Gemeinde ausw√§hlen oder Jahresslider bet√§tigen, um das Jahr der ersten Erw√§hnung in Urkunden zu sehen.</span>
    </div>

    <div class="loading hidden" id="loading">
      <div class="spinner" aria-hidden="true"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/topojson-client@3/dist/topojson-client.min.js"></script>
  <script>
    const MUNICIPALITY_FILE = "topojson/germany_municipalities_with_year.json";
    const WIKIPEDIA_BASE_URL = "https://de.wikipedia.org/wiki/";
    const DEFAULT_DETAIL = "Gemeinde ausw√§hlen oder Jahresslider bet√§tigen, um das Jahr der ersten Erw√§hnung in Urkunden zu sehen.";
    const YEAR_MIN = 600;
    const YEAR_MAX = 1850;
    const COLOR_STOPS = [
      { year: YEAR_MIN, color: "#065f46" }, // Dunkelgr√ºn
      { year: 1200, color: "#facc15" }, // Gelb
      { year: YEAR_MAX, color: "#b91c1c" }, // Rot
    ];
    const DEFAULT_COLOR = "#475569";
    const NEUTRAL_COLOR = "steelblue";
    const GRADIENT_FILL_OPACITY = 0.9;
    const NEUTRAL_FILL_OPACITY = 0.35;
    const FILTER_DIM_FACTOR = 0.25;
    const PLAYBACK_DELAY_MS = 35;
    const PLAYBACK_STEP = 1;

    const appContainer = document.getElementById("app");
    const infoPanel = document.getElementById("info-panel");
    const infoTitle = document.getElementById("info-title");
    const infoDetail = document.getElementById("info-detail");
    const loadingEl = document.getElementById("loading");
    const sliderShell = document.getElementById("slider-shell");
    const infoCloseButton = document.getElementById("info-close");
    const pointerIsCoarse = (() => {
      if (window.matchMedia) {
        try {
          return window.matchMedia("(pointer: coarse)").matches;
        } catch (error) {}
      }
      const touchPoints = navigator.maxTouchPoints || navigator.msMaxTouchPoints || 0;
      return touchPoints > 0;
    })();
    const yearSlider = document.getElementById("year-slider");
    const yearSliderValue = document.getElementById("year-slider-value");
    let yearThreshold = YEAR_MAX;
    let tapTimer = null;
    let gradientEnabled = true;
    let paletteControlButton = null;
    let infoPanelToggleButton = null;
    let playControlButton = null;
    let infoPanelEnabled = !isSmallViewport();
    let isPlaying = false;
    let playbackTimer = null;

    const map = L.map("map", {
      minZoom: 5,
      maxZoom: 13,
      zoomControl: true,
      zoomSnap: 0.25,
      zoomDelta: 0.5,
      wheelPxPerZoomLevel: 90,
      attributionControl: false,
      preferCanvas: true,
      doubleClickZoom: false,
    }).setView([51.1657, 10.4515], 6);

    L.tileLayer("https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png", {
      subdomains: "abcd",
      maxZoom: 19,
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/">CARTO</a>',
    }).addTo(map);

    const overlayPane = map.getPanes().overlayPane;
    const svg = d3.select(overlayPane).append("svg").attr("class", "overlay leaflet-zoom-animated");
    const root = svg.append("g");
    const maskLayer = root.append("path").attr("class", "germany-mask").attr("fill-rule", "evenodd");
    const featureLayer = root.append("g").attr("class", "feature-layer");

    const projector = d3.geoTransform({
      point(lng, lat) {
        const point = map.latLngToLayerPoint([lat, lng]);
        this.stream.point(point.x, point.y);
      },
    });

    const path = d3.geoPath().projection(projector);
    let municipalityFeatures = [];
    let germanyMaskFeature = null;

    map.on("move zoom moveend zoomend viewreset", () => window.requestAnimationFrame(syncOverlay));
    window.addEventListener("resize", () => {
      map.invalidateSize();
      syncOverlay();
      handleViewportChange();
    });
    handleViewportChange();
    const toolbarControl = L.control({ position: "topleft" });
    toolbarControl.onAdd = () => {
      const container = L.DomUtil.create("div", "leaflet-bar custom-map-controls");
      paletteControlButton = createControlButton(container, "üé®", "Farbverlauf deaktivieren");
      paletteControlButton.classList.add("palette-button");
      infoPanelToggleButton = createControlButton(container, "‚ÑπÔ∏è", "Infofeld ausblenden");
      infoPanelToggleButton.classList.add("info-toggle-button", "palette-button");
      playControlButton = createControlButton(container, "‚èØÔ∏è", "Animation starten");
      playControlButton.classList.add("playback-button", "palette-button");
      L.DomEvent.disableClickPropagation(container);
      L.DomEvent.disableScrollPropagation(container);
      return container;
    };
    toolbarControl.addTo(map);
    bindControlEvents();
    updatePaletteToggleUI();
    updateInfoPanelToggleUI();
    updatePlayButtonUI();
    initYearSlider();

    resetInfo();
    showLoading(true);

    fetch(MUNICIPALITY_FILE)
      .then((response) => {
        if (!response.ok) {
          throw new Error("TopoJSON konnte nicht geladen werden.");
        }
        return response.json();
      })
      .then((topology) => {
        const objectName = Object.keys(topology.objects)[0];
        const topoObject = topology.objects[objectName];
        const geojson = topojson.feature(topology, topoObject);
        municipalityFeatures = geojson.features;
        const merged = topojson.merge(topology, topoObject.geometries);
        germanyMaskFeature = buildMaskFeature(merged);
        drawFeatures();
        fitToFeatures(municipalityFeatures);
        syncOverlay();
      })
      .catch((error) => {
        console.error(error);
        setInfo("Fehler", "Die Gemeindedaten konnten nicht geladen werden.");
      })
      .finally(() => {
        showLoading(false);
      });

    if (infoPanel) {
      ["click", "pointerdown", "touchstart"].forEach((type) => {
        infoPanel.addEventListener(type, (event) => event.stopPropagation(), {
          passive: true,
        });
      });
    }
    if (infoCloseButton) {
      infoCloseButton.addEventListener("click", (event) => {
        event.preventDefault();
        setInfoPanelEnabled(false);
      });
    }

    function createControlButton(container, symbol, title) {
      const button = L.DomUtil.create("a", "leaflet-control-button", container);
      button.href = "#";
      button.setAttribute("role", "button");
      button.setAttribute("aria-label", title);
      button.title = title;
      button.innerHTML = `<span aria-hidden="true" style="font-size:1.35rem;line-height:1;display:inline-flex;align-items:center;justify-content:center;height:100%;">${symbol}</span>`;
      return button;
    }

    function isInfoPanelVisible() {
      if (!infoPanel || !infoPanelEnabled) return false;
      if (infoPanel.classList.contains("hidden-panel")) {
        return false;
      }
      const style = window.getComputedStyle(infoPanel);
      if (style.display === "none" || style.visibility === "hidden") {
        return false;
      }
      return true;
    }

    function positionSliderShell() {
      if (!sliderShell || !appContainer) return;
      const shellStyle = window.getComputedStyle(sliderShell);
      if (shellStyle.display === "none") {
        return;
      }
      const sliderWidth = sliderShell.offsetWidth;
      if (!sliderWidth) return;
      const containerWidth = appContainer.clientWidth;
      let left = (containerWidth - sliderWidth) / 2;
      const panelVisible = isInfoPanelVisible();
      if (panelVisible) {
        const panelBounds = infoPanel.getBoundingClientRect();
        const containerBounds = appContainer.getBoundingClientRect();
        const relativePanelRight = panelBounds.right - containerBounds.left;
        const minLeftWithPanel = relativePanelRight + 16;
        left = Math.max(left, minLeftWithPanel);
      }
      const minLeft = 24;
      const maxLeft = Math.max(minLeft, containerWidth - sliderWidth - 24);
      left = Math.min(Math.max(left, minLeft), maxLeft);
      sliderShell.style.left = `${left}px`;
      sliderShell.style.transform = "none";
    }

    function bindControlEvents() {
      if (paletteControlButton) {
        L.DomEvent.on(paletteControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          gradientEnabled = !gradientEnabled;
          updatePaletteToggleUI();
          refreshFeatureColors();
        });
      }
      if (infoPanelToggleButton) {
        L.DomEvent.on(infoPanelToggleButton, "click", (event) => {
          L.DomEvent.stop(event);
          setInfoPanelEnabled(!infoPanelEnabled);
        });
      }
      if (playControlButton) {
        L.DomEvent.on(playControlButton, "click", (event) => {
          L.DomEvent.stop(event);
          togglePlayback();
        });
      }
    }

    function updatePaletteToggleUI() {
      if (!paletteControlButton) return;
      const title = gradientEnabled ? "Farbverlauf deaktivieren" : "Farbverlauf aktivieren";
      paletteControlButton.classList.toggle("toggle-active", gradientEnabled);
      paletteControlButton.classList.toggle("palette-off", !gradientEnabled);
      paletteControlButton.setAttribute("aria-pressed", gradientEnabled ? "true" : "false");
      paletteControlButton.setAttribute("aria-label", title);
      paletteControlButton.title = title;
    }

    function updateInfoPanelToggleUI() {
      if (!infoPanelToggleButton) return;
      const title = infoPanelEnabled ? "Infofeld ausblenden" : "Infofeld einblenden";
      infoPanelToggleButton.classList.toggle("toggle-active", infoPanelEnabled);
      infoPanelToggleButton.classList.toggle("palette-off", !infoPanelEnabled);
      infoPanelToggleButton.setAttribute("aria-pressed", infoPanelEnabled ? "true" : "false");
      infoPanelToggleButton.setAttribute("aria-label", title);
      infoPanelToggleButton.title = title;
    }

    function updatePlayButtonUI() {
      if (!playControlButton) return;
      const title = isPlaying ? "Animation stoppen" : "Animation starten";
      playControlButton.classList.toggle("toggle-active", isPlaying);
      playControlButton.classList.toggle("palette-off", !isPlaying);
      playControlButton.setAttribute("aria-pressed", isPlaying ? "true" : "false");
      playControlButton.setAttribute("aria-label", title);
      playControlButton.title = title;
    }

    function setInfoPanelEnabled(enabled) {
      infoPanelEnabled = Boolean(enabled);
      updateInfoPanelToggleUI();
      applyInfoPanelVisibility();
      positionSliderShell();
    }

    function handleViewportChange() {
      applyInfoPanelVisibility();
      positionSliderShell();
    }

    function applyInfoPanelVisibility() {
      if (!infoPanel) return;
      infoPanel.classList.toggle("hidden-panel", !infoPanelEnabled);
      infoPanel.setAttribute("aria-hidden", infoPanelEnabled ? "false" : "true");
      const small = isSmallViewport();
      if (small) {
        infoPanel.classList.toggle("show-on-mobile", infoPanelEnabled);
      } else {
        infoPanel.classList.remove("show-on-mobile");
      }
      syncSliderVisibility();
    }

    function syncSliderVisibility() {
      if (!sliderShell) return;
      const shouldHide = isSmallViewport() && infoPanelEnabled;
      sliderShell.classList.toggle("slider-hidden", shouldHide);
    }

    function isSmallViewport() {
      if (window.matchMedia) {
        try {
          return window.matchMedia("(max-width: 640px)").matches;
        } catch (error) {}
      }
      return window.innerWidth <= 640;
    }

    function setInfo(title, detailHtml) {
      if (infoTitle) {
        infoTitle.textContent = title || "";
        infoTitle.style.display = title ? "block" : "none";
      }
      infoDetail.innerHTML = detailHtml;
    }

    function resetInfo() {
      setInfo("", DEFAULT_DETAIL);
    }

    function showLoading(show) {
      loadingEl.classList.toggle("hidden", !show);
    }

    function codeFor(feature) {
      return String(feature?.properties?.RS || feature?.properties?.AGS || feature?.properties?.ID_1 || "");
    }

    function nameFor(feature) {
      return feature?.properties?.GEN || feature?.properties?.NAME || "Unbenannt";
    }

    function yearFor(feature) {
      const raw = feature?.properties?.YR;
      const parsed = Number(raw);
      return Number.isFinite(parsed) ? parsed : null;
    }

    function clampYearValue(year) {
      if (year == null) return null;
      if (year < YEAR_MIN) return YEAR_MIN;
      if (year > YEAR_MAX) return YEAR_MAX;
      return year;
    }

    function hexToRgb(hex) {
      const value = hex.replace("#", "");
      const int = parseInt(value, 16);
      return {
        r: (int >> 16) & 255,
        g: (int >> 8) & 255,
        b: int & 255,
      };
    }

    function rgbToHex({ r, g, b }) {
      const toHex = (component) => component.toString(16).padStart(2, "0");
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function interpolateColor(colorA, colorB, t) {
      const start = hexToRgb(colorA);
      const end = hexToRgb(colorB);
      const clampT = Math.min(1, Math.max(0, t));
      const mix = {
        r: Math.round(start.r + (end.r - start.r) * clampT),
        g: Math.round(start.g + (end.g - start.g) * clampT),
        b: Math.round(start.b + (end.b - start.b) * clampT),
      };
      return rgbToHex(mix);
    }

    function colorForYearValue(year) {
      const clamped = clampYearValue(year);
      if (clamped == null) {
        return DEFAULT_COLOR;
      }
      for (let i = 0; i < COLOR_STOPS.length - 1; i += 1) {
        const current = COLOR_STOPS[i];
        const next = COLOR_STOPS[i + 1];
        if (clamped >= current.year && clamped <= next.year) {
          const span = next.year - current.year || 1;
          const t = (clamped - current.year) / span;
          return interpolateColor(current.color, next.color, t);
        }
      }
      return COLOR_STOPS[COLOR_STOPS.length - 1].color;
    }

    function baseFillFor(feature) {
      if (!gradientEnabled) {
        return NEUTRAL_COLOR;
      }
      const year = yearFor(feature);
      return year == null ? DEFAULT_COLOR : colorForYearValue(year);
    }

    function baseOpacityFor() {
      return gradientEnabled ? GRADIENT_FILL_OPACITY : NEUTRAL_FILL_OPACITY;
    }

    function lightenColor(hex, factor = 0.2) {
      return interpolateColor(hex, "#ffffff", factor);
    }

    function wikipediaLinkFor(feature) {
      const value = feature?.properties?.WI;
      if (!value) return "";
      const slug = String(value).trim();
      if (!slug) return "";
      if (/^https?:\/\//i.test(slug)) {
        return slug;
      }
      return `${WIKIPEDIA_BASE_URL}${slug}`;
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function updateInfoForFeature(feature) {
      const name = nameFor(feature);
      const year = yearFor(feature);
      const yearText = year != null ? escapeHtml(year) : "kein Jahr hinterlegt";
      const detail = `Erstmalig erw√§hnt: <strong>${yearText}</strong>`;
      setInfo(name, detail);
    }

    function featurePassesYearFilter(feature) {
      const year = yearFor(feature);
      if (year == null) return true;
      return year <= yearThreshold;
    }

    function styleForFeature(feature) {
      const passesFilter = featurePassesYearFilter(feature);
      const baseColor = passesFilter ? baseFillFor(feature) : DEFAULT_COLOR;
      const opacity = passesFilter ? baseOpacityFor() : Math.max(0.08, baseOpacityFor() * FILTER_DIM_FACTOR);
      return { fill: baseColor, opacity };
    }

    function highlightPath(pathNode, active) {
      if (!pathNode) return;
      const node = d3.select(pathNode);
      const baseColor = node.attr("data-base-fill") || NEUTRAL_COLOR;
      const baseOpacity = Number(node.attr("data-base-opacity")) || baseOpacityFor();
      if (active) {
        node
          .attr("stroke", "rgba(248, 250, 252, 0.85)")
          .attr("stroke-width", 0.8)
          .style("fill", lightenColor(baseColor, 0.25))
          .style("fill-opacity", Math.min(1, baseOpacity + 0.15))
          .classed("selected", true);
        return;
      }
      node
        .attr("stroke", "none")
        .attr("stroke-width", 0)
        .style("fill", baseColor)
        .style("fill-opacity", baseOpacity)
        .classed("selected", false);
    }

    function attachFeatureEvents(selection) {
      selection
        .on("pointerenter", function (event, feature) {
          highlightPath(this, true);
          updateInfoForFeature(feature);
        })
        .on("pointerleave", function () {
          highlightPath(this, false);
          resetInfo();
        })
        .on("click", function (event, feature) {
          event.preventDefault();
          handleFeatureActivation(feature);
        })
        .on("dblclick", function (event, feature) {
          event.preventDefault();
          handleFeatureActivation(feature, { force: true });
        });
    }

    function handleFeatureActivation(feature, { force = false } = {}) {
      updateInfoForFeature(feature);
      const link = wikipediaLinkFor(feature);
      if (!link) {
        return;
      }

      if (pointerIsCoarse && !force) {
        if (tapTimer) {
          clearTimeout(tapTimer);
          tapTimer = null;
          openWikipedia(link);
          return;
        }
        tapTimer = setTimeout(() => {
          tapTimer = null;
        }, 350);
        return;
      }

      openWikipedia(link);
    }

    function openWikipedia(link) {
      const href = typeof link === "string" ? link.trim() : "";
      if (!href) return;
      const newWindow = window.open(href, "_blank", "noopener,noreferrer");
      if (newWindow && typeof newWindow.focus === "function") {
        newWindow.focus();
      }
    }

    function applyBaseFill(selection) {
      selection.each(function (feature) {
        const { fill: baseColor, opacity: baseOpacity } = styleForFeature(feature);
        d3.select(this)
          .attr("data-base-fill", baseColor)
          .attr("data-base-opacity", baseOpacity)
          .style("fill", baseColor)
          .style("fill-opacity", baseOpacity)
          .attr("stroke", "none")
          .attr("stroke-width", 0);
      });
    }

    function refreshFeatureColors() {
      featureLayer.selectAll("path.feature").each(function (feature) {
        const node = d3.select(this);
        const { fill: baseColor, opacity: baseOpacity } = styleForFeature(feature);
        node.attr("data-base-fill", baseColor);
        node.attr("data-base-opacity", baseOpacity);
        if (node.classed("selected")) {
          node
            .attr("stroke", "rgba(248, 250, 252, 0.85)")
            .attr("stroke-width", 0.8)
            .style("fill", lightenColor(baseColor, 0.25))
            .style("fill-opacity", Math.min(1, baseOpacity + 0.15));
        } else {
          node
            .attr("stroke", "none")
            .attr("stroke-width", 0)
            .style("fill", baseColor)
            .style("fill-opacity", baseOpacity);
        }
      });
    }

    function initYearSlider() {
      if (!yearSlider) return;
      yearSlider.setAttribute("min", YEAR_MIN);
      yearSlider.setAttribute("max", YEAR_MAX);
      yearSlider.value = String(yearThreshold);
      updateSliderValue(yearThreshold);
      yearSlider.addEventListener("input", (event) => {
        const next = Number(event.target.value);
        if (!Number.isFinite(next)) return;
        stopPlayback();
        setYearThreshold(next, { syncSlider: false });
      });
    }

    function setYearThreshold(value, { syncSlider = true } = {}) {
      if (!Number.isFinite(value)) return;
      const clamped = Math.max(YEAR_MIN, Math.min(YEAR_MAX, Math.round(value)));
      yearThreshold = clamped;
      if (syncSlider && yearSlider) {
        yearSlider.value = String(clamped);
      }
      updateSliderValue(clamped);
      refreshFeatureColors();
    }

    function updateSliderValue(value) {
      if (yearSliderValue) {
        yearSliderValue.textContent = value;
      }
    }

    function togglePlayback() {
      if (isPlaying) {
        stopPlayback();
      } else {
        startPlayback();
      }
    }

    function startPlayback() {
      if (isPlaying) return;
      isPlaying = true;
      updatePlayButtonUI();
      setYearThreshold(YEAR_MIN);
      playbackTimer = window.setInterval(() => {
        if (yearThreshold >= YEAR_MAX) {
          stopPlayback();
          return;
        }
        setYearThreshold(yearThreshold + PLAYBACK_STEP);
      }, PLAYBACK_DELAY_MS);
    }

    function stopPlayback() {
      if (playbackTimer) {
        clearInterval(playbackTimer);
        playbackTimer = null;
      }
      if (!isPlaying) return;
      isPlaying = false;
      updatePlayButtonUI();
    }

    function drawFeatures() {
      if (!municipalityFeatures.length) return;
      const selection = featureLayer
        .selectAll("path.feature")
        .data(municipalityFeatures, (feature) => codeFor(feature));

      selection.exit().remove();

      const entered = selection.enter().append("path").attr("class", "feature municipality-level");
      const merged = entered.merge(selection);
      applyBaseFill(merged);
      attachFeatureEvents(merged);
      featureLayer.selectAll("path").attr("role", "presentation");
    }

    function syncOverlay() {
      if (!municipalityFeatures.length) {
        return;
      }
      const bounds = path.bounds({
        type: "FeatureCollection",
        features: municipalityFeatures,
      });
      const topLeft = bounds[0];
      const bottomRight = bounds[1];

      svg
        .attr("width", bottomRight[0] - topLeft[0])
        .attr("height", bottomRight[1] - topLeft[1])
        .style("left", `${topLeft[0]}px`)
        .style("top", `${topLeft[1]}px`);

      root.attr("transform", `translate(${-topLeft[0]}, ${-topLeft[1]})`);

      featureLayer.selectAll("path").attr("d", path);
      if (germanyMaskFeature) {
        maskLayer.attr("d", path(germanyMaskFeature));
      }
    }

    function fitToFeatures(features) {
      if (!features.length) return;
      const featureCollection = { type: "FeatureCollection", features };
      const bounds = d3.geoBounds(featureCollection);
      const sw = L.latLng(bounds[0][1], bounds[0][0]);
      const ne = L.latLng(bounds[1][1], bounds[1][0]);
      const padding = window.innerWidth < 768 ? [10, 10] : [30, 30];
      map.fitBounds(L.latLngBounds(sw, ne), { padding });
    }

    function buildMaskFeature(merged) {
      const outerRing = [
        [-180, -90],
        [180, -90],
        [180, 90],
        [-180, 90],
        [-180, -90],
      ];
      let rings = [];
      const geometry = merged && merged.type ? merged : merged?.geometry;
      if (!geometry) {
        return null;
      }
      if (geometry.type === "Polygon") {
        rings = geometry.coordinates;
      } else if (geometry.type === "MultiPolygon") {
        rings = geometry.coordinates.flat();
      }
      return {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [outerRing, ...rings],
        },
      };
    }
  </script>
</body>
</html>
